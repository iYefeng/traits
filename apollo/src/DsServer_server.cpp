// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/concurrency/PlatformThreadFactory.h>
#include <thrift/concurrency/ThreadManager.h>
#include <thrift/transport/TSocket.h>
#include <thrift/TToString.h>
#include <thrift/server/TThreadedServer.h>
#include <thrift/server/TThreadPoolServer.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <thrift/concurrency/PosixThreadFactory.h>
#include <thrift/server/TNonblockingServer.h>

#include <boost/make_shared.hpp>
#include <iostream>
#include <stdexcept>
#include <sstream>

#include <kchashdb.h>
#include "../gen-cpp/DsServer.h"
#include "../gen-cpp/dss_types.h"

using namespace std;
using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;
using namespace apache::thrift::concurrency;

using boost::shared_ptr;

using namespace kyotocabinet;

using namespace  dss;

class KC {
  public:
    static KC *insatnce() 
    {
      static KC instance_;
      return &instance_; 
    }

    ~KC() {
      closeDB();
    }
    
    int initDB()
    {
      if (!db.open("casket.kct", 
            TreeDB::OWRITER | TreeDB::OCREATE)) {
        cerr << "open error: " << db.error().name() << endl;
        return -1;
      }
      return 0;
    }

    int closeDB()
    {
      if (!db.close()) {
        cerr << "close error: " << db.error().name() << endl;
        return -1;
      }  
      return 0;
    }
    
    TreeDB& getDB() 
    {
      return db;
    }

  private:
    TreeDB db;
};

class DsServerHandler : virtual public DsServerIf {
 public:
  DsServerHandler() {
    // Your initialization goes here
  }

  void ping(std::string& _return) {
    // Your implementation goes here
    //printf("ping\n");
    KC::insatnce()->getDB().set("foo", "hop");
    _return = "pong";
  }

  void get(std::string& _return, const std::string& key) {
    // Your implementation goes here
    string value;
    KC::insatnce()->getDB().get(key, &value);
    _return = value;
    //printf("get\n");
  }

  void getm(std::vector<std::string> & _return, const std::vector<std::string> & keys) {
    // Your implementation goes here
    _return.push_back("hello world2");
    printf("getm\n");
  }

  void put(const request& req) {
    // Your implementation goes here
    KC::insatnce()->getDB().set(req.key, req.value);
    //printf("put\n");
  }

  void putm(const std::vector<request> & reqs) {
    // Your implementation goes here
    printf("putm\n");
  }

  void status(std::string& _return) {
    // Your implementation goes here
    _return = "data server is ok\n";
    printf("status\n");
  }
};

class DsServerCloneFactory : virtual public DsServerIfFactory {
  public:
    virtual ~DsServerCloneFactory() {}
    virtual DsServerIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo)
    {
      boost::shared_ptr<TSocket> sock = boost::dynamic_pointer_cast<TSocket>(connInfo.transport);
      cout << "Incoming connection\n";
      cout << "\tSocketInfo: "  << sock->getSocketInfo() << "\n";
      cout << "\tPeerHost: "    << sock->getPeerHost() << "\n";
      cout << "\tPeerAddress: " << sock->getPeerAddress() << "\n";
      cout << "\tPeerPort: "    << sock->getPeerPort() << "\n";
      return new DsServerHandler;
    }
    virtual void releaseHandler(DsServerIf* handler) {
      delete handler;
    }
};


int main(int argc, char **argv) {
  int port = 9090;
  boost::shared_ptr<DsServerCloneFactory> handler(new DsServerCloneFactory);
  boost::shared_ptr<TProcessorFactory> processor(new DsServerProcessorFactory(handler));
  boost::shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  boost::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  boost::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());
  boost::shared_ptr<ThreadManager> threadManager = \
    ThreadManager::newSimpleThreadManager(9);  
  boost::shared_ptr<PosixThreadFactory> threadFactory = \
    boost::shared_ptr<PosixThreadFactory>(new PosixThreadFactory());  
  threadManager->threadFactory(threadFactory);  
  threadManager->start();
  TNonblockingServer server(
        processor,  
        protocolFactory,  
        port,  
        threadManager);  
  KC::insatnce()->initDB();

  cout << "Starting the server..." << endl;
  server.serve();
  KC::insatnce()->closeDB();
  cout << "Done." << endl;
  return 0;
}

